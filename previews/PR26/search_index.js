var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Criteria","page":"API","title":"Criteria","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ACriterion\nDCriterion\nECriterion\nFisherACriterion\nFisherDCriterion\nFisherECriterion","category":"page"},{"location":"api/#DynamicOED.ACriterion","page":"API","title":"DynamicOED.ACriterion","text":"struct ACriterion <: DynamicOED.AbstractInformationCriterion\n\nThe A-Criterion for experimental design.\n\ntr(inv(F))\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicOED.DCriterion","page":"API","title":"DynamicOED.DCriterion","text":"struct DCriterion <: DynamicOED.AbstractInformationCriterion\n\nThe D-Criterion for experimental design.\n\ndet(inv(F))\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicOED.ECriterion","page":"API","title":"DynamicOED.ECriterion","text":"struct ECriterion <: DynamicOED.AbstractInformationCriterion\n\nThe E-Criterion for experimental design.\n\nmax(eigvals(F))\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicOED.FisherACriterion","page":"API","title":"DynamicOED.FisherACriterion","text":"struct FisherACriterion <: DynamicOED.AbstractInformationCriterion\n\nThe Fisher A-Criterion for experimental design.\n\n-tr(F)\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicOED.FisherDCriterion","page":"API","title":"DynamicOED.FisherDCriterion","text":"struct FisherDCriterion <: DynamicOED.AbstractInformationCriterion\n\nThe Fisher D-Criterion for experimental design.\n\n-det(F)\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicOED.FisherECriterion","page":"API","title":"DynamicOED.FisherECriterion","text":"struct FisherECriterion <: DynamicOED.AbstractInformationCriterion\n\nThe Fisher E-Criterion for experimental design.\n\n-min(eigvals(F))\n\n\n\n\n\n","category":"type"},{"location":"api/#Problem","page":"API","title":"Problem","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DynamicOED.OEDProblem\nDynamicOED.Timegrid","category":"page"},{"location":"api/#DynamicOED.OEDProblem","page":"API","title":"DynamicOED.OEDProblem","text":"struct OEDProblem{S, O, T, A, DO}\n\nThe basic definition of an optimal experimental design problem.\n\nFields\n\nsystem: The optimal experimental design system in form of an ODESystem\nobjective: The objective criterion\ntimegrid: The time grid\nalg: Solver for the differential equations\ndiffeq_options: Differential equations options\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicOED.Timegrid","page":"API","title":"DynamicOED.Timegrid","text":"struct Timegrid{V, I, G, T}\n\nA structure for holding a multi-variable time grid. \n\nFields\n\nvariables: The variables\nindicators: The indicator for switching variables\ntimegrids: The individual time grids\ntimespans: The overall time grid\n\n\n\n\n\n","category":"type"},{"location":"api/#Symbolic-Differentiation-Backends","page":"API","title":"Symbolic Differentiation Backends","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DynamicOED.MTKBackend","category":"page"},{"location":"api/#DynamicOED.MTKBackend","page":"API","title":"DynamicOED.MTKBackend","text":"struct MTKBackend <: DynamicOED.AbstractAugmentationBackened\n\nUses ModelingToolkit as a backened to augment the system.\n\n\n\n\n\n","category":"type"},{"location":"api/#ModelingToolkit-Extensions","page":"API","title":"ModelingToolkit Extensions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DynamicOED.VariableRate\nDynamicOED.FisherState\nDynamicOED.MeasurementFunction\nDynamicOED.VariableIC","category":"page"},{"location":"api/#DynamicOED.VariableRate","page":"API","title":"DynamicOED.VariableRate","text":"struct VariableRate\n\nIndicator that a given state is subject to a fixed rate. Is used for modeling the rate of observation of observed variables and the rate of control for control variables. If the provided rate is a Real, it is assumed that the resulting time grid is given in fractions of the time unit.  If the provided rate is a Int, it is assumed that the resulting time grid is divided in rate equidistant intervals. \n\n@variables y(t) [measurement_rate=0.1] # Create a variable measured every 0.1 t\n@variables y(t) [measurement_rate=0.1] # Create a variable measured every 0.1 t\n@parameters c [input=true, measurement_rate=2] # Create a control variable which acts 2 times over the course of the simulation\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicOED.FisherState","page":"API","title":"DynamicOED.FisherState","text":"struct FisherState\n\nIndicator that a given variable is a state of the fisher information matrix. \n\n@variables F[1:3, 1:3] [fisher_state=true]\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicOED.MeasurementFunction","page":"API","title":"DynamicOED.MeasurementFunction","text":"struct MeasurementFunction\n\nIndicator that a given variable is a measurement function. \n\n@variables w=1.0 [measurement_function=true]\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicOED.VariableIC","page":"API","title":"DynamicOED.VariableIC","text":"struct VariableIC\n\nIndicator that a given state variable's initial condition is unknown.\n\n@variables x(t)=1.0 [variable_ic=true]\n\n\n\n\n\n","category":"type"},{"location":"theory/#Theoretical-Background","page":"Theory","title":"Theoretical Background","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"note: Note\nThis section serves as a short introduction. For a more detailed introduction, please refer to this paper.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"DynamicOED.jl is focused on deriving optimal experimental designs for differential (algebraic) systems of the form","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n0 = f(dotx x p t u)  \ny = h(x)\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"on a fixed time horizon mathcal T = t_0 t_f where we have states x(cdot)  mathcal T mapsto mathbb R^n_x and y and h mathbbR^n_x mapsto mathbbR^n_h indicate the observed states and the measurement function, respectively.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"In the optimal experimental design problem the experimental setting, e.g., initial conditions and controls, as well as the decision when to measure are determined such that the collected data from this experiment can be used to accurately estimate the model's parameters. The problem we are solving reads","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n    undersetx G F w x_0 u tautextmin  phi(F(t_f) + tau I) \n    textsubject to\n      0            =     f(dot x x p t u)\n     0            =     f_dot x(dot x x p t u) dotG + f_x(dot x x p t u)G + f_p(dot x x p t u)\n     dot F    =     sum_i=1^n_h w_i(t) (h^i_x(x) G)^top (h^i_x(x) G) \n     dot z   =     w\n     x(t_0)         =     x_0 quad  G(t_0) = 0 quad F(t_0) = 0 quad z(t_0) = 0\n     u          in   mathcalU\n     w         in   mathcal W\n     z(t_f) - M   leq  0 \nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where the first and second constraint denote the dynamical system and the variational differential (algebraic) equation for the sensitivities of the solution x(cdot) with respect to the uncertain parameters, respectively. They are given in an implicit form. Here, f_dot x (f_x) denotes the partial derivative of f with respect to dot x (x). ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The objective phi(F(t_f) + tau I) of Bolza type is a suited objective function, e.g., the A-criterion phi(F) = textrmtrace(F^-1(t_f)), and tau in mathbb R_+ denotes a regularization term.  The evolution of the symmetric FIM F  mathcalT mapsto mathbbR^n_p times n_p is influenced by the measurement function h, the sensitivities  G  mathcalT mapsto mathbbR^n_x times n_p and the sampling decisions w(t) in 01^n_h. The latter are the main optimization variables and represent the decision whether to measure at a given time point or not. The sampling decisions are then accumulated in the variables z and constrained by M in mathbbR^n_h_+. Additionally, controls u in mathcalU may be present to stimulate the system.","category":"page"},{"location":"examples/lotka/#Design-of-Experiments-for-Lotka-Volterra","page":"Lotka-Volterra","title":"Design of Experiments for Lotka-Volterra","text":"","category":"section"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"Now, let us consider the well-known Lotka-Volterra system  ","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"beginaligned\ndotx_1 = p_1 x - p_2 x y \ndotx_2 = - p_3 y + p_4 x y\ny(x)      = x\nendaligned ","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"where we are interested in estimating the parameters p_2 and p_4. We can measure the states directly with some fixed measurement rate.","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"We start by using ModelingToolkit.jl and DynamicOED.jl to model the system.","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"using DynamicOED\nusing ModelingToolkit\nusing Optimization, OptimizationMOI, Ipopt\nusing Plots\n\n@variables t\n@variables x(t)=0.5 [description = \"Biomass Prey\"] y(t)=0.7 [description =\"Biomass Predator\"]\n@variables u(t) [description = \"Control\"]\n@parameters p[1:2]=[1.0; 1.0] [description = \"Fixed Parameters\", tunable = false]\n@parameters p_est[1:2]=[1.0; 1.0] [description = \"Tunable Parameters\", tunable = true]\nD = Differential(t)\n@variables obs(t)[1:2] [description = \"Observed\", measurement_rate = 96]\nobs = collect(obs)\n\n@named lotka_volterra = ODESystem(\n    [\n        D(x) ~   p[1]*x - p_est[1]*x*y;\n        D(y) ~  -p[2]*y + p_est[2]*x*y\n    ], tspan = (0.0, 12.0),\n    observed = obs .~ [x; y]\n)","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"Like in the Design of Experiments for a simple system, we added important information:","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"The observed variables are initialized with a measurement_rate. This time we use an integer measurement rate, resulting in 96 subintervals of equal length.\nThe parameters p_2 and p_4 are marked as tunable. ","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"Now we can augment the system with the needed expressions for the sensitivities and the Fisher Information matrix by constructing an OEDSystem. ","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"@named oed_system = OEDSystem(lotka_volterra)","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"With this augmented ODESystem we can set up the OEDProblem by specifying the criterion we want to optimize.","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"oed_problem = OEDProblem(structural_simplify(oed_system), DCriterion())","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"We choose the DCriterion, which minimizes the determinant of the inverse of the Fisher Information matrix. For constraining the time we can measure by defining a ConstraintSystem from ModelingToolkit on the optimization variables. We want to measure for at most 4 units of time. Since we discretized the observed variables on 96 subintervals on a time horizon of 12 units of time, this translates to an upper limit on the measurements of 32.","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"optimization_variables = states(oed_problem)\n\nconstraint_equations = [\n    sum(optimization_variables.measurements.w₁) ≲ 32,\n    sum(optimization_variables.measurements.w₂) ≲ 32,\n]\n\n@named constraint_system = ConstraintsSystem(\n    constraint_equations, collect(optimization_variables), []\n)\nnothing # hide","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"note: Note\nThe optimization_variables contain several groups of variables, namely measurements, controls, initial_conditions, and regularization. measurements represent the decision to observe at a specific time point at the grid. We currently work with the naming convention w_i for the i-th observed equation. Currently we need to collect the states before passing them into the ConstraintsSystem!","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"Finally, we are now able to convert our OEDProblem into an OptimizationProblem and solve it.","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"note: Note\nCurrently we only support AutoForwardDiff() as an AD backend.","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"optimization_problem = OptimizationProblem(\n    oed_problem, AutoForwardDiff(), constraints = constraint_system,\n    integer_constraints = false\n)\n\noptimal_design = solve(optimization_problem, Ipopt.Optimizer(); hessian_approximation=\"limited-memory\")\n\nu_opt = optimal_design.u + optimization_problem.u0","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"Now we want to visualize the found solution. ","category":"page"},{"location":"examples/lotka/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"function plotoed(problem, res)\n\n    predictor = DynamicOED.build_predictor(problem)\n    x_opt, t_opt = predictor(res)\n    timegrid = problem.timegrid\n\n    state_plot = plot(t_opt, x_opt[1:2, :]', xlabel = \"Time\", ylabel = \"States\", label = [\"x\" \"y\"])\n\n    measures_plot = plot()\n    for i in 1:2\n        t_measures = vcat(first.(timegrid.timegrids[i]), last.(timegrid.timegrids[i]))\n        sort!(t_measures)\n        unique!(t_measures)\n        _measurements = getfield(res.measurements |> NamedTuple, timegrid.variables[i])\n        plot!(t_measures,\n            vcat(_measurements, last(_measurements)),\n            line = :steppost,\n            xlabel = \"Time\",\n            ylabel = \"Measurement\",\n            color = i == 2 ? :red : :blue,\n            label = string(timegrid.variables[i]))\n    end\n\n    plot(state_plot, measures_plot, layout=(2,1))\nend\n\nplotoed(oed_problem, u_opt)","category":"page"},{"location":"examples/1D/#Design-of-Experiments-for-a-simple-system","page":"Linear System","title":"Design of Experiments for a simple system","text":"","category":"section"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"As a pedagogical example, lets start with a simple system.","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"beginaligned\ndotx = p_1 x  \ny = x\nendaligned ","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"where the state x is dependent on a single, uncertain parameter p_1. We assume we can observe the state directly with some fixed measurement rate.","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"We start by using ModelingToolkit.jl and DynamicOED.jl to model the system.","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"using DynamicOED\nusing ModelingToolkit\nusing Optimization, OptimizationMOI, Ipopt\n\n@variables t x(t) = 1.0 [description = \"State\"] \n@variables y(t) [description=\"Observations\", measurement_rate = 0.1]\n@parameters p = -2.0 [description= \"Uncertain parameter\", tunable = true]\n\nD = Differential(t)\n\n@named simple_system = ODESystem(\n    [\n        D(x) ~ p*x\n    ], tspan = (0., 1.), \n    observed = [\n        y  ~ x\n    ]\n)","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"Note that in order to prepare the system for optimal experimental design, we added two important information:","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"The parameter p_1 is marked as tunable. \nThe observed variable y has a measurement_rate.","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"This way, we can limit the set of tunable parameters of the system and derive time grids for the observations independently. To derive the associated system for experimental design, we simply construct an OEDSystem. ","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"@named oed_system = OEDSystem(simple_system)","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"This step augments the initial system with all necessary information, e.g. the sensitivity equations and the dynamics of the fisher information matrix. The output is simply another ODESystem, hence we can use available transformations and simplification routines from ModelingToolkit. ","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"Next, we associate an optimization criterion to the system and instantiate it over a specific time grid.","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"oed_problem = OEDProblem(structural_simplify(oed_system), DCriterion())","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"We choose the DCriterion, which minimizes the determinant of the inverse of the Fisher Information. Given that the optimal solution would be to measure all occurrences, we also need to add constraints to the measurement function.","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"optimization_variables = states(oed_problem)","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"note: Note\nThe optimization_variables contain several groups of variables, namely measurements, controls, initial_conditions, and regularization. measurements represent the decision to observe at a specific time point at the grid. We currently work with the naming convention w_i for the i-th observed equation. Currently we need to collect the states before passing them into the ConstraintsSystem!","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"Now we have access to all optimization variables as a ComponentArray. We are interested in choosing at most 3 measurements, so we add a ConstraintsSystem from ModelingToolkit.","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"constraint_equations = [\n    sum(optimization_variables.measurements.w₁) ≲ 3,\n]\n\n@named constraint_system = ConstraintsSystem(\n    constraint_equations, collect(optimization_variables), []\n)\nnothing # hide","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"Finally, we are now able to convert our OEDProblem into an OptimizationProblem and solve it.","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"note: Note\nCurrently we only support AutoForwardDiff() as an AD backend.","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"optimization_problem = OptimizationProblem(\n    oed_problem, AutoForwardDiff(), constraints = constraint_system,\n    integer_constraints = false\n)\n\noptimal_design = solve(optimization_problem, Ipopt.Optimizer(); hessian_approximation=\"limited-memory\")","category":"page"},{"location":"examples/1D/","page":"Linear System","title":"Linear System","text":"We see that we have indeed recovered a bang-bang solution to our problem, even though we only solve a relaxed problem. The interested reader can find a more in depth explanation here. ","category":"page"},{"location":"#DynamicOED.jl","page":"Home","title":"DynamicOED.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Repository for optimal experimental design for differential equations using optimal control.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DynamicOED.jl uses multiple packages of Julia's SciML ecosystem, especially ModelingToolkit.jl, DifferentialEquations.jl and Optimization.jl to define optimal experimental design problems using optimal control.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is not registered yet, but once it is you can use this section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Assuming that you already have Julia correctly installed, it suffices to import DynamicOED.jl in the standard way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"DynamicOED\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The packages relevant to the core functionality of DynamicOED.jl will be imported accordingly and, in most cases, you do not have to worry about the manual installation of dependencies. However, you will need to add the specific optimizer packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To solve the underlying optimization problem, please refer to Optimization.jl for available solvers.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently we support Ordinary Differential Equations and Differential Algebraic Equations.\nRelaxed and Integer formulations of the underlying problem\nUnknown initial conditions\nContinuous and discrete controls (in terms of the variable)\nVariable (measurement) rates for observed and control variables\nCustom constraints ","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using DynamicOED\nusing ModelingToolkit\nusing Optimization, OptimizationMOI, Ipopt\n\n# Define the differential equations\n@variables t\n@variables x(t)=1.0 [description = \"State\"]\n@parameters p[1:1]=-2.0 [description = \"Fixed parameter\", tunable = true]\n@variables obs(t) [description = \"Observed\", measurement_rate = 10]\nD = Differential(t)\n\n@named simple_system = ODESystem([\n        D(x) ~ p[1] * x,\n    ], tspan = (0.0, 1.0),\n    observed = obs .~ [x.^2])\n\n@named oed = OEDSystem(simple_system)\noed = structural_simplify(oed)\n\n# Augment the original problem to an OED problem\noed_problem = OEDProblem(structural_simplify(oed), FisherACriterion())\n\n# Define an MTK Constraint system over the grid variables\noptimization_variables = states(oed_problem)\n        \nconstraint_equations = [\n      sum(optimization_variables.measurements.w₁) ≲ 3,\n]\n\n@named constraint_set = ConstraintsSystem(constraint_equations, optimization_variables,[])\n\n# Initialize the optimization problem\noptimization_problem = OptimizationProblem(oed_problem, AutoForwardDiff(),\n      constraints = constraint_set,\n      integer_constraints = false)\n\n# Solven for the optimal values of the observed variables\nsolve(optimization_problem, Ipopt.Optimizer())","category":"page"}]
}
