<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lotka-Volterra · DynamicOED.jl</title><meta name="title" content="Lotka-Volterra · DynamicOED.jl"/><meta property="og:title" content="Lotka-Volterra · DynamicOED.jl"/><meta property="twitter:title" content="Lotka-Volterra · DynamicOED.jl"/><meta name="description" content="Documentation for DynamicOED.jl."/><meta property="og:description" content="Documentation for DynamicOED.jl."/><meta property="twitter:description" content="Documentation for DynamicOED.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DynamicOED.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../1D/">Linear System</a></li><li class="is-active"><a class="tocitem" href>Lotka-Volterra</a></li></ul></li><li><a class="tocitem" href="../../theory/">Theory</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Lotka-Volterra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lotka-Volterra</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Design-of-Experiments-for-Lotka-Volterra"><a class="docs-heading-anchor" href="#Design-of-Experiments-for-Lotka-Volterra">Design of Experiments for Lotka-Volterra</a><a id="Design-of-Experiments-for-Lotka-Volterra-1"></a><a class="docs-heading-anchor-permalink" href="#Design-of-Experiments-for-Lotka-Volterra" title="Permalink"></a></h1><p>Now, let us consider the well-known Lotka-Volterra system  </p><p class="math-container">\[\begin{aligned}
\dot{x_1} &amp;= p_1 x - p_2 x y\\ 
\dot{x_2} &amp;= - p_3 y + p_4 x y\\
y(x)      &amp;= x
\end{aligned} \]</p><p>where we are interested in estimating the parameters <span>$p_2$</span> and <span>$p_4$</span>. We can measure the states directly with some fixed measurement rate.</p><p>We start by using <a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit.jl</a> and DynamicOED.jl to model the system.</p><pre><code class="language-julia hljs">using DynamicOED
using ModelingToolkit
using Optimization, OptimizationMOI, Ipopt
using Plots

@variables t
@variables x(t)=0.5 [description = &quot;Biomass Prey&quot;] y(t)=0.7 [description =&quot;Biomass Predator&quot;]
@variables u(t) [description = &quot;Control&quot;]
@parameters p[1:2]=[1.0; 1.0] [description = &quot;Fixed Parameters&quot;, tunable = false]
@parameters p_est[1:2]=[1.0; 1.0] [description = &quot;Tunable Parameters&quot;, tunable = true]
D = Differential(t)
@variables obs(t)[1:2] [description = &quot;Observed&quot;, measurement_rate = 96]
obs = collect(obs)

@named lotka_volterra = ODESystem(
    [
        D(x) ~   p[1]*x - p_est[1]*x*y;
        D(y) ~  -p[2]*y + p_est[2]*x*y
    ], tspan = (0.0, 12.0),
    observed = obs .~ [x; y]
)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} x\left( t \right)}{\mathrm{d}t} =&amp; p_1 x\left( t \right) - p_{est_1} x\left( t \right) y\left( t \right) \\
\frac{\mathrm{d} y\left( t \right)}{\mathrm{d}t} =&amp;  - p_2 y\left( t \right) + p_{est_2} x\left( t \right) y\left( t \right)
\end{align}
 \]</p><p>Like in the <a href="../1D/#Design-of-Experiments-for-a-simple-system">Design of Experiments for a simple system</a>, we added important information:</p><ul><li>The observed variables are initialized with a <a href="../../api/#DynamicOED.VariableRate"><code>measurement_rate</code></a>. This time we use an integer measurement rate, resulting in <span>$96$</span> subintervals of equal length.</li><li>The parameters <span>$p_2$</span> and <span>$p_4$</span> are marked as <code>tunable</code>. </li></ul><p>Now we can augment the system with the needed expressions for the sensitivities and the Fisher Information matrix by constructing an <code>OEDSystem</code>. </p><pre><code class="language-julia hljs">@named oed_system = OEDSystem(lotka_volterra)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} x\left( t \right)}{\mathrm{d}t} =&amp; p_1 x\left( t \right) - p_{est_1} x\left( t \right) y\left( t \right) \\
\frac{\mathrm{d} y\left( t \right)}{\mathrm{d}t} =&amp;  - p_2 y\left( t \right) + p_{est_2} x\left( t \right) y\left( t \right) \\
0 =&amp;  - \frac{\mathrm{d}}{\mathrm{d}t} G(t)_{1}ˏ_1 - x\left( t \right) y\left( t \right) + G(t)_{1}ˏ_1 \left( p_1 - p_{est_1} y\left( t \right) \right) - G(t)_{2}ˏ_1 p_{est_1} x\left( t \right) \\
0 =&amp;  - \frac{\mathrm{d}}{\mathrm{d}t} G(t)_{2}ˏ_1 + G(t)_{1}ˏ_1 p_{est_2} y\left( t \right) + G(t)_{2}ˏ_1 \left(  - p_2 + p_{est_2} x\left( t \right) \right) \\
0 =&amp;  - \frac{\mathrm{d}}{\mathrm{d}t} G(t)_{1}ˏ_2 + G(t)_{1}ˏ_2 \left( p_1 - p_{est_1} y\left( t \right) \right) - G(t)_{2}ˏ_2 p_{est_1} x\left( t \right) \\
0 =&amp;  - \frac{\mathrm{d}}{\mathrm{d}t} G(t)_{2}ˏ_2 + x\left( t \right) y\left( t \right) + G(t)_{1}ˏ_2 p_{est_2} y\left( t \right) + G(t)_{2}ˏ_2 \left(  - p_2 + p_{est_2} x\left( t \right) \right) \\
\frac{\mathrm{d}}{\mathrm{d}t} F(t)_{1}ˏ_1 =&amp; G(t)_{1}ˏ_1^{2} w_1 + G(t)_{2}ˏ_1^{2} w_2 \\
\frac{\mathrm{d}}{\mathrm{d}t} F(t)_{1}ˏ_2 =&amp; G(t)_{1}ˏ_1 G(t)_{1}ˏ_2 w_1 + G(t)_{2}ˏ_1 G(t)_{2}ˏ_2 w_2 \\
\frac{\mathrm{d}}{\mathrm{d}t} F(t)_{2}ˏ_2 =&amp; G(t)_{1}ˏ_2^{2} w_1 + G(t)_{2}ˏ_2^{2} w_2 \\
Q(t)_{1}ˏ_1 =&amp; G(t)_{1}ˏ_1 \\
Q(t)_{2}ˏ_1 =&amp; G(t)_{2}ˏ_1 \\
Q(t)_{1}ˏ_2 =&amp; G(t)_{1}ˏ_2 \\
Q(t)_{2}ˏ_2 =&amp; G(t)_{2}ˏ_2
\end{align}
 \]</p><p>With this augmented <code>ODESystem</code> we can set up the <code>OEDProblem</code> by specifying the criterion we want to optimize.</p><pre><code class="language-julia hljs">oed_problem = OEDProblem(structural_simplify(oed_system), DCriterion())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OEDProblem{ModelingToolkit.ODESystem, DCriterion, DynamicOED.Timegrid{Tuple{Symbol, Symbol}, Matrix{Int64}, Tuple{Vector{Tuple{Float64, Float64}}, Vector{Tuple{Float64, Float64}}}, Vector{Tuple{Float64, Float64}}}, OrdinaryDiffEq.Tsit5{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, NamedTuple{(), Tuple{}}}(ModelingToolkit.ODESystem(0x0000000000000005, Symbolics.Equation[Differential(t)(x(t)) ~ p[1]*x(t) - p_est[1]*x(t)*y(t), Differential(t)(y(t)) ~ -p[2]*y(t) + p_est[2]*x(t)*y(t), Differential(t)((G(t))[1, 1]) ~ -x(t)*y(t) + (G(t))[1, 1]*(p[1] - p_est[1]*y(t)) - (G(t))[2, 1]*p_est[1]*x(t), Differential(t)((G(t))[2, 1]) ~ (G(t))[1, 1]*p_est[2]*y(t) + (G(t))[2, 1]*(-p[2] + p_est[2]*x(t)), Differential(t)((G(t))[1, 2]) ~ (G(t))[1, 2]*(p[1] - p_est[1]*y(t)) - (G(t))[2, 2]*p_est[1]*x(t), Differential(t)((G(t))[2, 2]) ~ x(t)*y(t) + (G(t))[1, 2]*p_est[2]*y(t) + (G(t))[2, 2]*(-p[2] + p_est[2]*x(t)), Differential(t)((F(t))[1, 1]) ~ ((G(t))[1, 1]^2)*w₁ + ((G(t))[2, 1]^2)*w₂, Differential(t)((F(t))[1, 2]) ~ (G(t))[1, 1]*(G(t))[1, 2]*w₁ + (G(t))[2, 1]*(G(t))[2, 2]*w₂, Differential(t)((F(t))[2, 2]) ~ ((G(t))[1, 2]^2)*w₁ + ((G(t))[2, 2]^2)*w₂], t, Any[x(t), y(t), (G(t))[1, 1], (G(t))[2, 1], (G(t))[1, 2], (G(t))[2, 2], (F(t))[1, 1], (F(t))[1, 2], (F(t))[2, 2]], SymbolicUtils.BasicSymbolic[p_est[1], p[1], p_est[2], p[2], w₁, w₂], (0.0, 12.0), Dict{Any, Any}(:F =&gt; F(t), :p =&gt; p, :y =&gt; y(t), :G =&gt; G(t), :Q =&gt; Q(t), :w₂ =&gt; w₂, :obs =&gt; obs(t), :p_est =&gt; p_est, :w₁ =&gt; w₁, :x =&gt; x(t)…), Any[], Symbolics.Equation[(obs(t))[1] ~ x(t), (obs(t))[2] ~ y(t), (Q(t))[1, 1] ~ (G(t))[1, 1], (Q(t))[2, 1] ~ (G(t))[2, 1], (Q(t))[1, 2] ~ (G(t))[1, 2], (Q(t))[2, 2] ~ (G(t))[2, 2]], Base.RefValue{Vector{Symbolics.Num}}(Symbolics.Num[]), Base.RefValue{Any}(Matrix{Symbolics.Num}(undef, 0, 0)), Base.RefValue{Any}(Matrix{Symbolics.Num}(undef, 0, 0)), Base.RefValue{Matrix{Symbolics.Num}}(Matrix{Symbolics.Num}(undef, 0, 0)), Base.RefValue{Matrix{Symbolics.Num}}(Matrix{Symbolics.Num}(undef, 0, 0)), :oed_system, ModelingToolkit.ODESystem[], Dict{Any, Any}((G(t))[1, 2] =&gt; 0.0, (F(t))[1, 1] =&gt; 0.0, p_est[1] =&gt; 1.0, (F(t))[2, 2] =&gt; 0.0, (G(t))[1, 1] =&gt; 0.0, p[2] =&gt; 1.0, p_est[2] =&gt; 1.0, (G(t))[2, 2] =&gt; 0.0, x(t) =&gt; 0.5, w₂ =&gt; 0.0…), nothing, nothing, nothing, ModelingToolkit.SymbolicContinuousCallback[ModelingToolkit.SymbolicContinuousCallback(Symbolics.Equation[], Symbolics.Equation[])], ModelingToolkit.SymbolicDiscreteCallback[], nothing, nothing, TearingState of ModelingToolkit.ODESystem, ModelingToolkit.Substitutions(Symbolics.Equation[(Q(t))[1, 1] ~ (G(t))[1, 1], (Q(t))[2, 1] ~ (G(t))[2, 1], (Q(t))[1, 2] ~ (G(t))[1, 2], (Q(t))[2, 2] ~ (G(t))[2, 2]], [Int64[], [1], [1, 2], [1, 2, 3]], nothing), true, nothing, nothing, nothing, ModelingToolkit.ODESystem(0x0000000000000005, Symbolics.Equation[Differential(t)(x(t)) ~ p[1]*x(t) - p_est[1]*x(t)*y(t), Differential(t)(y(t)) ~ -p[2]*y(t) + p_est[2]*x(t)*y(t), 0.0 ~ -Differential(t)((G(t))[1, 1]) - x(t)*y(t) + (G(t))[1, 1]*(p[1] - p_est[1]*y(t)) - (G(t))[2, 1]*p_est[1]*x(t), 0.0 ~ -Differential(t)((G(t))[2, 1]) + (G(t))[1, 1]*p_est[2]*y(t) + (G(t))[2, 1]*(-p[2] + p_est[2]*x(t)), 0.0 ~ -Differential(t)((G(t))[1, 2]) + (G(t))[1, 2]*(p[1] - p_est[1]*y(t)) - (G(t))[2, 2]*p_est[1]*x(t), 0.0 ~ -Differential(t)((G(t))[2, 2]) + x(t)*y(t) + (G(t))[1, 2]*p_est[2]*y(t) + (G(t))[2, 2]*(-p[2] + p_est[2]*x(t)), Differential(t)((F(t))[1, 1]) ~ ((G(t))[1, 1]^2)*w₁ + ((G(t))[2, 1]^2)*w₂, Differential(t)((F(t))[1, 2]) ~ (G(t))[1, 1]*(G(t))[1, 2]*w₁ + (G(t))[2, 1]*(G(t))[2, 2]*w₂, Differential(t)((F(t))[2, 2]) ~ ((G(t))[1, 2]^2)*w₁ + ((G(t))[2, 2]^2)*w₂, (Q(t))[1, 1] ~ (G(t))[1, 1], (Q(t))[2, 1] ~ (G(t))[2, 1], (Q(t))[1, 2] ~ (G(t))[1, 2], (Q(t))[2, 2] ~ (G(t))[2, 2]], t, SymbolicUtils.BasicSymbolic{Real}[x(t), y(t), (G(t))[1, 1], (G(t))[2, 1], (G(t))[1, 2], (G(t))[2, 2], (F(t))[1, 1], (F(t))[1, 2], (F(t))[2, 2], (Q(t))[1, 1], (Q(t))[2, 1], (Q(t))[1, 2], (Q(t))[2, 2]], SymbolicUtils.BasicSymbolic[p_est[1], p[1], p_est[2], p[2], w₁, w₂], (0.0, 12.0), Dict{Any, Any}(:F =&gt; F(t), :p =&gt; p, :y =&gt; y(t), :G =&gt; G(t), :Q =&gt; Q(t), :w₂ =&gt; w₂, :obs =&gt; obs(t), :p_est =&gt; p_est, :w₁ =&gt; w₁, :x =&gt; x(t)…), Any[], Symbolics.Equation[(obs(t))[1] ~ x(t), (obs(t))[2] ~ y(t)], Base.RefValue{Vector{Symbolics.Num}}(Symbolics.Num[]), Base.RefValue{Any}(Matrix{Symbolics.Num}(undef, 0, 0)), Base.RefValue{Any}(Matrix{Symbolics.Num}(undef, 0, 0)), Base.RefValue{Matrix{Symbolics.Num}}(Matrix{Symbolics.Num}(undef, 0, 0)), Base.RefValue{Matrix{Symbolics.Num}}(Matrix{Symbolics.Num}(undef, 0, 0)), :oed_system, ModelingToolkit.ODESystem[], Dict{Any, Any}((G(t))[1, 2] =&gt; 0.0, (F(t))[1, 1] =&gt; 0.0, p[2] =&gt; 1.0, (G(t))[2, 2] =&gt; 0.0, (F(t))[1, 2] =&gt; 0.0, p[1] =&gt; 1.0, w₁ =&gt; 0.0, y(t) =&gt; 0.7, p_est[1] =&gt; 1.0, (F(t))[2, 2] =&gt; 0.0…), nothing, nothing, nothing, ModelingToolkit.SymbolicContinuousCallback[ModelingToolkit.SymbolicContinuousCallback(Symbolics.Equation[], Symbolics.Equation[])], ModelingToolkit.SymbolicDiscreteCallback[], nothing, nothing, nothing, nothing, true, nothing, nothing, nothing, nothing)), DCriterion(), DynamicOED.Timegrid{Tuple{Symbol, Symbol}, Matrix{Int64}, Tuple{Vector{Tuple{Float64, Float64}}, Vector{Tuple{Float64, Float64}}}, Vector{Tuple{Float64, Float64}}}((:w₁, :w₂), [1 2 … 95 96; 1 2 … 95 96], ([(0.0, 0.125), (0.125, 0.25), (0.25, 0.375), (0.375, 0.5), (0.5, 0.625), (0.625, 0.75), (0.75, 0.875), (0.875, 1.0), (1.0, 1.125), (1.125, 1.25)  …  (10.75, 10.875), (10.875, 11.0), (11.0, 11.125), (11.125, 11.25), (11.25, 11.375), (11.375, 11.5), (11.5, 11.625), (11.625, 11.75), (11.75, 11.875), (11.875, 12.0)], [(0.0, 0.125), (0.125, 0.25), (0.25, 0.375), (0.375, 0.5), (0.5, 0.625), (0.625, 0.75), (0.75, 0.875), (0.875, 1.0), (1.0, 1.125), (1.125, 1.25)  …  (10.75, 10.875), (10.875, 11.0), (11.0, 11.125), (11.125, 11.25), (11.25, 11.375), (11.375, 11.5), (11.5, 11.625), (11.625, 11.75), (11.75, 11.875), (11.875, 12.0)]), [(0.0, 0.125), (0.125, 0.25), (0.25, 0.375), (0.375, 0.5), (0.5, 0.625), (0.625, 0.75), (0.75, 0.875), (0.875, 1.0), (1.0, 1.125), (1.125, 1.25)  …  (10.75, 10.875), (10.875, 11.0), (11.0, 11.125), (11.125, 11.25), (11.25, 11.375), (11.375, 11.5), (11.5, 11.625), (11.625, 11.75), (11.75, 11.875), (11.875, 12.0)]), Tsit5(; stage_limiter! = trivial_limiter!, step_limiter! = trivial_limiter!, thread = static(false),), NamedTuple())</code></pre><p>We choose the <a href="../../api/#DynamicOED.DCriterion"><code>DCriterion</code></a>, which minimizes the determinant of the inverse of the Fisher Information matrix. For constraining the time we can measure by defining a <code>ConstraintSystem</code> from ModelingToolkit on the optimization variables. We want to measure for at most <span>$4$</span> units of time. Since we discretized the observed variables on <span>$96$</span> subintervals on a time horizon of <span>$12$</span> units of time, this translates to an upper limit on the measurements of <span>$32$</span>.</p><pre><code class="language-julia hljs">optimization_variables = states(oed_problem)

constraint_equations = [
    sum(optimization_variables.measurements.w₁) ≲ 32,
    sum(optimization_variables.measurements.w₂) ≲ 32,
]

@named constraint_system = ConstraintsSystem(
    constraint_equations, optimization_variables, []
)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>optimization_states</code> contain several groups of variables, namely <code>measurements</code>, <code>controls</code>, <code>initial_conditions</code>, and <code>regularization</code>. <code>measurements</code> represent the decision to observe at a specific time point at the grid. We currently work with the naming convention <code>w_i</code> for the i-th observed equation.</p></div></div><p>Finally, we are now able to convert our <a href="../../api/#DynamicOED.OEDProblem"><code>OEDProblem</code></a> into an <code>OptimizationProblem</code> and <code>solve</code> it.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently we only support <code>AutoForwardDiff()</code> as an AD backend.</p></div></div><pre><code class="language-julia hljs">optimization_problem = OptimizationProblem(
    oed_problem, AutoForwardDiff(), constraints = constraint_system,
    integer_constraints = false
)

optimal_design = solve(optimization_problem, Ipopt.Optimizer(); hessian_approximation=&quot;limited-memory&quot;)

u_opt = optimal_design.u + optimization_problem.u0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ComponentVector{Float64}(controls = Float64[], initial_conditions = Float64[], measurements = (w₁ = [8.150444691085876e-7, 8.163093694231291e-7, 8.189840660977134e-7, 8.233196800264876e-7, 8.296873643852418e-7, 8.386102058879344e-7, 8.508142555929592e-7, 8.673092593637045e-7, 8.895185223545978e-7, 9.194947024680233e-7  …  0.9999989892807954, 0.9999976003263097, 2.4075867388525625e-5, 2.641192014873092e-6, 1.5899207116454061e-6, 1.2374298383970999e-6, 1.0704250376395544e-6, 9.783547235904154e-7, 9.232085383202934e-7, 8.884586865311912e-7], w₂ = [6.082383847588166e-7, 6.08655813142258e-7, 6.094145554437966e-7, 6.104660817182134e-7, 6.117935440021537e-7, 6.134082806905058e-7, 6.153495754639441e-7, 6.1768770873747e-7, 6.205308857948444e-7, 6.24037330504233e-7  …  0.9999994678008942, 0.9999993693655769, 0.9999992146046348, 0.9999989479780069, 0.9999984062904621, 0.9999968096403159, 0.999965904022932, 4.081571854526682e-6, 2.049937558186124e-6, 1.4270493773830689e-6]), regularization = 0.9999999900100008)</code></pre><p>Now we want to visualize the found solution. </p><pre><code class="language-julia hljs">function plotoed(problem, res)

    predictor = DynamicOED.build_predictor(problem)
    x_opt, t_opt = predictor(res)
    timegrid = problem.timegrid

    state_plot = plot(t_opt, x_opt[1:2, :]&#39;, xlabel = &quot;Time&quot;, ylabel = &quot;States&quot;, label = [&quot;x&quot; &quot;y&quot;])

    measures_plot = plot()
    for i in 1:2
        t_measures = vcat(first.(timegrid.timegrids[i]), last.(timegrid.timegrids[i]))
        sort!(t_measures)
        unique!(t_measures)
        _measurements = getfield(res.measurements |&gt; NamedTuple, timegrid.variables[i])
        plot!(t_measures,
            vcat(_measurements, last(_measurements)),
            line = :steppost,
            xlabel = &quot;Time&quot;,
            ylabel = &quot;Measurement&quot;,
            color = i == 2 ? :red : :blue,
            label = string(timegrid.variables[i]))
    end

    plot(state_plot, measures_plot, layout=(2,1))
end

plotoed(oed_problem, u_opt)</code></pre><img src="734edebb.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../1D/">« Linear System</a><a class="docs-footer-nextpage" href="../../theory/">Theory »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.0 on <span class="colophon-date" title="Friday 1 December 2023 10:45">Friday 1 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
